<script>
    /**

## PropertiesFromAncestorBehavior

A <a href="https://www.polymer-project.org" target="_blank">Polymer</a> Behavior for a web component to take a property value from the closest ancestor that has it. Supports change events.

Such a tool can be useful for ubiquitous properties (think language of the UI, currency, [`disabled` state to every input of a form](#how-to-native-like-support-for-fieldset-disabled), etc.) which would otherwise pollute attributes of every component with same boilerplate expression, or force usage of a global variable (usually without binding to changes).

### Usage:

Technically, it's a behavior factory function. To have a behavior instance created, you call the `PropertiesFromAncestorBehavior()`.
```JavaScript
Polymer({
    is: 'example-descendant-component',
    behaviors: [
        PropertiesFromAncestorBehavior({
            // Just declaring a property here is enough to make it work.
            myProp1: {
                // Optionally, you can provide a default. If no ancestor is found, `defaultValue` will to be used:
                defaultValue: 123, // (don't use the polymer's 'value:' for this though, because it may cause double initialization - once with such value, once with the value from ancestor (if they're different). That's because we can only reach the ancestor on 'attached', which happens after defaults get applied.

                // See "API Reference - Per-Property settings" for all available options

                // If you don't care about polylint, you can avoid repetition and just put here all other property settings. They get passed to declaration of this property on the element:
                notify: true,
                observer: '_myProp1Changed',
            },
        }),
    ],
    properties: {
            // But if you want to keep polylint happy, you need to list the property here too:
            myProp1: {
                // Custom settings still work:
                notify: true,
                observer: '_myProp1Changed',
                // But you don't want to use 'value:' here but rather 'defaultValue:' above. See comment there for 'why'.
            },
    }
})
```

the above declaration will make the properties available in `<example-descendant-component>`s template:
```HTML
<template>
    myProp1 value is {{myProp1}}
    <br/>
    myProp2 value is {{myProp2}}
</template>
```

while their values will come from the closest ancestor that has the corresponding dash-case attribute.
```HTML
<example-container-component my-prop1="some value" my-prop2="some other value"><!-- Container can also be a simple HTML <div>. As long as it has the attributes. These attributes are a requirement to discover the ancestor. If the element also has matching properties, they instead will be taken and their changes listened to. -->
  <example-descendant-component></example-descendant-component>
</example-container-component>
```

# API Reference - Per-Property settings #
These parameters can be specified for each property:
- **defaultValue** (_Optional_)  
  If no ancestor is found, `defaultValue` will to be used.  
- **ancestorMatches** (_Optional_)
  of type <a href="ttps://www.w3.org/TR/selectors4/" target="_blank">HTML Selector</a>  
  - Instead of looking for ancestor with the dash-case attribute, you can provide a selector. This especially is needed for boolean attributes that start with 'false', because it's represented as no attribute at all.
  Example:
    `ancestorMatches: '.ancestor-markup-class'` - will listen to the closest ancestor with `class="ancestor-markup-class"`
- **ancestorObservedItem** (_Optional_)  
  of enum type  
    `PropertiesFromAncestorBehavior.ObservedItem.PROPERTY_CHANGED_EVENT` (default)  
    `PropertiesFromAncestorBehavior.ObservedItem.ATTRIBUTE`  
  If the ancestor doesn't emit `*-changed` events, you can use `ATTRIBUTE` to tell the behavior that it should use a <a href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver" target="_blank">MutationObserver</a> to listen to the attribute.  
  Take note that in this case the handlers will not fire in the same thread as the change, so if you need to schedule some work after the handlers, you will need to use `setTimeout(..., 0)`.


# HOW-TO: Native-like support for `<fieldset disabled>`
The native HTML form input elements like `<input>`, `<button>`, `<select>` elements don't require you to pass the `disabled` attribute to each usage. You use the ancestor <a href="https://html.spec.whatwg.org/multipage/form-elements.html#attr-fieldset-disabled" target="_blank">`fieldset` disabled</a> feature to disable all of the containing inputs.

Here's how this behavior can be used to support the same feature when your web component isn't built from these native inputs:
```
<template>
    <span on-tap="{{handleTap}}">Something only clickable when enabled</span>
</template>
...
Polymer({
    behaviors: [
        PropertiesFromAncestorBehavior({
            disabled: {
                // Use 'ancestorMatches' to provide a way to match while it's enabled (has no disabled attribute)
                ancestorMatches: 'fieldset',

                // <fieldset> has a disabled property, but changing it doesn't emit 'disabled-changed' event, so we must observe the attribute:
                ancestorObservedItem: PropertiesFromAncestorBehavior.ObservedItem.ATTRIBUTE,

                // Specify type, to properly get empty 'disabled' attribute deserialized into 'true':
                type: Boolean,
            },
        }),
    ],
    handleTap: () => {
        if (this.disabled) return;
    
        // If we got here, we're enabled. Handle legitimate click:
        this.DoSomething();
    },
    ...
})
```

@polymerBehavior
@demo demo/index.html
*/
    PropertiesFromAncestorBehavior = function (propsDefObject) {
        'use strict';
        return Object.keys(propsDefObject).map(function (propName) {
                let propDef = propsDefObject[propName];

                if (propDef.ancestorObservedItem && !(propDef.ancestorObservedItem in PropertiesFromAncestorBehavior.ObservedItem))
                    throw 'Unknown ancestorObservedItem: "' + propDef.ObservedItem + '". Please use one of values from PropertiesFromAncestorBehavior.ObservedItem';

                let dashedName = fromCamelCaseSymbolToDash(propName);
                let changeEventName = dashedName + '-changed';

                let behaviorDefinition = {
                    properties: {},
                    attached: function () {
                        let ancestorToObserve = polymerClosestThatMatches(this, propDef.ancestorMatches || '[' + dashedName + ']');
                        this.__propertiesFromAncestorBehavior = {
                        };

                        this[propName] =
                            !ancestorToObserve ?
                                propDef.defaultValue
                                :
                                propName in ancestorToObserve ?
                                    ancestorToObserve[propName]
                                    :
                                    this.deserialize(ancestorToObserve.getAttribute(dashedName), this.getPropertyInfo(propName).type);

                        if (ancestorToObserve) {
                            let observer;
                            if (propDef.ancestorObservedItem === PropertiesFromAncestorBehavior.ObservedItem.ATTRIBUTE || !(propName in ancestorToObserve)) {
                                observer = new MutationObserver(function (mutations) {
                                    this[propName] = this.deserialize(ancestorToObserve.getAttribute(dashedName), this.getPropertyInfo(propName).type)
                                }.bind(this));
                                observer.observe(ancestorToObserve, {
                                    attributes: true,
                                    attributeFilter: [dashedName],
                                });
                            }
                            else {
                                let changeEventListener = function () {
                                    this[propName] = ancestorToObserve[propName];
                                }.bind(this);

                                ancestorToObserve.addEventListener(changeEventName, changeEventListener);

                                observer = {
                                    disconnect: function () {
                                        ancestorToObserve.removeEventListener(changeEventName, changeEventListener);
                                    },
                                };
                            }

                            this.__propertiesFromAncestorBehavior.observer = observer;
                        }
                    },
                    detached: function () {
                        if (this.__propertiesFromAncestorBehavior.observer)
                            this.__propertiesFromAncestorBehavior.observer.disconnect();
                    },
                };

                behaviorDefinition.properties[propName] = propDef;

                return behaviorDefinition;
            });

        /// An equivalent of Element.closest(selector) for Polymer (uses `Element.domHost` to support children that are only being built, whose ancestors haven't been attached themselves yet).
        function polymerClosestThatMatches(e, selector) {
            if (e.matches && e.matches(selector) || (!e.matches && /*IE11*/e.msMatchesSelector(selector)))
                return e;
            else {
                let parent = e.parentElement || e.domHost;
                return parent ? polymerClosestThatMatches(parent, selector) : null;
            }
        }

        /// Improved (no '-' for 1st char if uppercase) version of https://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
        function fromCamelCaseSymbolToDash(string) {
            return string.replace(/[A-Z]/g, function (match, offset) { return (offset !== 0 ? "-" : "") + match.toLowerCase(); });
        }
    };
    PropertiesFromAncestorBehavior.ObservedItem = {
        ATTRIBUTE: "ATTRIBUTE",
        PROPERTY_CHANGED_EVENT: "PROPERTY_CHANGED_EVENT",
    };
</script>